(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{210:function(e,t,a){"use strict";a.r(t);var r=a(6),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue响应式讲解-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue响应式讲解-object"}},[e._v("#")]),e._v(" vue响应式讲解-object")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("原理：\nvue通过Object.defineProperty这个api来实现object响应式原理，他可以检测对象属性的获取和更改。利用这个原理，通过递归的方式，把data对象里的属性包括嵌套对象数组等进行监测，其中通过getter进行获取数据，setter更新数据。")])]),e._v(" "),a("li",[a("p",[e._v("dep依赖管理器：")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  *依赖收集：\n    在getter这里，vue进行了依赖收集（也就是谁调用了这个数据，也可以讲解为依赖调用了这个数据），调用dep.depend()函数。dep是一个依赖管理器，吧某个数据的依赖统一收集起来（依赖有不确定性，调用的次数不唯一），他拥有增删改查功能，而depend函数就是获取相应的数据本身。内部则获取window.target这个唯一对象，而window.target此时为watcher实例本身。\n  \n  *依赖更新：\n    在setter这里，vue通过调用dep.notify()来获取更改后的数据，来进行更新，内部则调用了watcher实例的update函数。\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[e._v("watcher实例：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  *getter：\n    我们所说的谁谁谁调用了数据，可以表达为某个依赖调用了某个数据。实际上这个依赖是watcher实例。当数据被真正的依赖调用时，vue会创建一个watcher实例，然后赋值给window.target这个唯一对象，然后再触发getter，通过depend函数吧watcher实例添加到dep依赖管理器，最后会吧window.target=undefined释放掉。\n\n  *setter：\n    当有依赖更新时，触发了setter，setter会触发通过在依赖管理器中与之对应的watcher实例的update函数，而update函数会吧数据进行一个更新替换。\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[e._v("缺点：\nObject.defineProperty无法监测到对象属性的添加和删除、只能监测更改和获取，vue通过封装vue.set()和vue.delete()这个两个api来解决问题。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);